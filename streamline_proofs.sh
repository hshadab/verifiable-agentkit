#!/bin/bash
# streamline_proofs.sh - Add KYC and remove math proofs, keep only 3 main use cases

set -e

echo "ğŸ¯ Streamlining to 3 main proof types: Location, AI Content, Circle KYC"
echo ""

cd ~/agentkit

# Create comprehensive backup
echo "ğŸ“ Creating backups..."
cp langchain_service.py langchain_service.py.pre_streamline_backup
cp src/main.rs src/main.rs.pre_streamline_backup
[ -f static/index.html ] && cp static/index.html static/index.html.pre_streamline_backup

echo "âœ… Backups created"

# 1. Create KYC WASM file
echo ""
echo "ğŸ” Creating Circle KYC WASM file..."

cat > zkengine/example_wasms/prove_kyc.wat << 'EOFWASM'
(module
  (func $main (param $wallet_hash i32) (param $kyc_approved i32) (result i32)
    ;; Zero-knowledge Circle KYC compliance proof
    ;; Proves wallet passed Circle KYC without revealing:
    ;; - Wallet owner identity
    ;; - Personal information
    ;; - KYC risk assessment details
    ;; - Transaction history
    ;;
    ;; wallet_hash: Hash of wallet address (preserves privacy)
    ;; kyc_approved: 1=approved by Circle, 0=rejected
    ;;
    ;; Returns: Deterministic proof of KYC compliance
    ;; Formula: (wallet_hash * 31 + kyc_approved * 1000) % 999983
    ;; Creates verifiable relationship without revealing wallet details
    
    local.get $wallet_hash
    i32.const 31
    i32.mul
    
    local.get $kyc_approved
    i32.const 1000
    i32.mul
    
    i32.add
    i32.const 999983
    i32.rem_u
  )
  (export "main" (func $main))
)
EOFWASM

echo "âœ… Created prove_kyc.wat"

# 2. Streamline LangChain service - keep only 3 proof types
echo ""
echo "ğŸ Streamlining LangChain service..."

python3 << 'EOFPYTHON'
import re

with open('langchain_service.py', 'r') as f:
    content = f.read()

# Replace available functions section
old_functions = r'Available proof functions:.*?fibonacci\(n\) - Prove the nth Fibonacci number'
new_functions = '''Available proof functions:
1. prove_kyc(wallet_hash, kyc_status) - Prove Circle KYC compliance without revealing wallet identity or personal details (wallet_hash: numeric hash of wallet, kyc_status: 1=approved)
2. prove_ai_content(content_hash, auth_type) - Prove AI-generated content authenticity and integrity (content_hash: numeric ID, auth_type: 1=signature, 2=hash, 3=full)
3. prove_location(city, device_id) - Prove device location within city boundaries (San Francisco, New York, London)

CIRCLE KYC PROOF EXAMPLES:
- "prove kyc compliance" â†’ Generate proof that wallet passed Circle KYC without revealing identity
- "verify kyc status" â†’ Prove KYC approval without disclosing wallet owner or risk assessment details  
- "kyc proof" â†’ Create zero-knowledge proof of regulatory compliance for DeFi access

When users request KYC proofs, you should:
1. Generate the proof intent with prove_kyc function
2. Explain how zero-knowledge proofs enable regulatory compliance while preserving privacy
3. Describe Circle KYC webhook integration (rampSession.kycApproved) 
4. Mention applications in DeFi, DEX access, and institutional adoption
5. Emphasize that wallet identity and personal details remain completely private

AI CONTENT PROOF EXAMPLES:
- "prove ai content authenticity" â†’ Generate authenticity proof for AI-generated content
- "verify ai generated content" â†’ Prove content was generated by AI and hasn't been tampered with
- "ai content verification" â†’ Create cryptographic proof of AI content integrity

When users request AI content proofs, you should:
1. Generate the proof intent with prove_ai_content function
2. Explain how zero-knowledge proofs can verify AI content without revealing the content itself
3. Describe applications in content verification, deepfake detection, and AI model attestation
4. Mention use cases in media authenticity and digital provenance

LOCATION PROOF EXAMPLES'''

content = re.sub(old_functions, new_functions, content, flags=re.DOTALL)

# Replace patterns with only 3 types
old_patterns_start = r"patterns = \{\s*'prove_ai_content':"
patterns_replacement = '''patterns = {
        'prove_kyc': [
            r'prove\\s+kyc\\s+compliance',
            r'kyc\\s+compliance',
            r'verify\\s+kyc\\s+status',
            r'prove\\s+kyc',
            r'kyc\\s+proof',
            r'kyc\\s+verification',
            r'circle\\s+kyc',
            r'regulatory\\s+compliance',
            r'compliance\\s+proof',
            r'kyc\\s+approved',
            r'prove\\s+compliance'
        ],
        'prove_ai_content':'''

content = re.sub(old_patterns_start, patterns_replacement, content)

# Remove all math patterns - find and remove fibonacci through count_until sections
patterns_to_remove = ['fibonacci', 'add', 'multiply', 'factorial', 'is_even', 'square', 'max', 'count_until']
for pattern in patterns_to_remove:
    # Remove the pattern and its associated list
    pattern_regex = rf"'{pattern}':\s*\[.*?\],?\s*"
    content = re.sub(pattern_regex, '', content, flags=re.DOTALL)

# Update the args logic for streamlined functions
old_args = r"if func == 'prove_ai_content':\s*args = \[\"42\", \"1\"\]"
new_args = '''if func == 'prove_kyc':
                        args = ["12345", "1"]  # wallet_hash=12345, kyc_approved=1
                    elif func == 'prove_ai_content':
                        args = ["42", "1"]  # content_hash=42, auth_type=1'''

content = re.sub(old_args, new_args, content)

# Update complexity analyzer
complexity_updates = {
    'fibonacci': '',
    'factorial': '',
    'is_even': '',
    'square': '',
    'max': '',
    'count_until': ''
}

# Add prove_kyc to complexity analyzer
kyc_complexity = '''        elif function == "prove_kyc":
            return (50, f"Circle KYC compliance proof with wallet_hash: {args[0] if len(args) > 0 else '12345'}, kyc_status: {args[1] if len(args) > 1 else '1'} (1=approved).")'''

# Insert before prove_ai_content
content = re.sub(r'(elif function == "prove_ai_content":)', kyc_complexity + '\n        \\1', content)

# Remove math function complexity checks
for func in patterns_to_remove:
    func_regex = rf'\s*elif function == "{func}":.*?return \(.*?\)\s*'
    content = re.sub(func_regex, '', content, flags=re.DOTALL)

# Remove try/except block for int parsing since we don't have math functions anymore
content = re.sub(r'try:\s*if function == "fibonacci":.*?except:\s*return \(50, "Unable to analyze complexity. Using default step size 50."\)', 
                'if function == "prove_location":\n            return (50, f"Location proof for DePIN network.")\n        elif function == "prove_kyc":\n            return (50, f"Circle KYC compliance proof with wallet_hash: {args[0] if len(args) > 0 else \'12345\'}, kyc_status: {args[1] if len(args) > 1 else \'1\'} (1=approved).")\n        elif function == "prove_ai_content":\n            return (50, f"AI content authenticity proof with content_hash: {args[0] if len(args) > 0 else \'42\'}, auth_type: {args[1] if len(args) > 1 else \'1\'}.")\n        else:\n            return (50, f"Simple operation: {function}.")', 
                content, flags=re.DOTALL)

with open('langchain_service.py', 'w') as f:
    f.write(content)

print("âœ… Streamlined LangChain service to 3 proof types")
EOFPYTHON

# 3. Update Rust backend
echo ""
echo "ğŸ¦€ Updating Rust backend..."

python3 << 'EOFPYTHON'
import re

with open('src/main.rs', 'r') as f:
    content = f.read()

# Replace the wasm_file match with only 3 functions
old_match = r'let wasm_file = match intent\.function\.as_str\(\) \{.*?\};'
new_match = '''let wasm_file = match intent.function.as_str() {
                    "prove_kyc" => "prove_kyc.wat",
                    "prove_ai_content" => "prove_ai_content.wat",
                    "prove_location" => "prove_location.wat", 
                    _ => {
                        return NlResponse {
                            message: String::new(),
                            data: Some(json!({
                                "error": format!("Unknown function: {}. Available: prove_kyc, prove_ai_content, prove_location", intent.function)
                            })),
                        };
                    }
                };'''

content = re.sub(old_match, new_match, content, flags=re.DOTALL)

with open('src/main.rs', 'w') as f:
    f.write(content)

print("âœ… Updated Rust backend")
EOFPYTHON

# 4. Restart services
echo ""
echo "ğŸ”„ Restarting services..."

sudo lsof -ti:8002 | xargs kill -9 2>/dev/null || true
sudo lsof -ti:8001 | xargs kill -9 2>/dev/null || true
sleep 3

export WASM_DIR=$PWD/zkengine/example_wasms
export ZKENGINE_BINARY=$PWD/zkengine/zkEngine_dev/wasm_file

cargo run &
source langchain_env/bin/activate && python langchain_service.py &

sleep 5

echo ""
echo "ğŸ‰ Successfully streamlined to 3 main proof types!"
echo ""
echo "ğŸ¯ Available Proof Types:"
echo ""
echo "1. ğŸ” Circle KYC Compliance"
echo "   Commands: 'prove kyc compliance', 'kyc proof'"
echo "   Purpose: Regulatory compliance without revealing identity"
echo ""
echo "2. ğŸ¤– AI Content Authenticity" 
echo "   Commands: 'prove ai content authenticity'"
echo "   Purpose: Verify AI content without revealing content"
echo ""
echo "3. ğŸ“ DePIN Location Proofs"
echo "   Commands: 'prove device location in San Francisco'"
echo "   Purpose: Location verification for rewards"
echo ""
echo "âŒ Removed: fibonacci, add, multiply, factorial, square, max, count_until"
echo ""
echo "ğŸ§ª Test: 'prove kyc compliance'"
echo "ğŸ“± Access: http://localhost:8001"
