use axum::{
    extract::{ws::{Message, WebSocket, WebSocketUpgrade}, State},
    response::{Html, IntoResponse, Json},
    routing::{get, post},
    Router,
};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use serde_json::json;
use sha2::{Digest, Sha256};
use std::{
    collections::HashMap,
    fs,
    path::Path,
    process::{Command, Stdio},
    sync::Arc,
    time::Instant,
};
use tokio::sync::{Mutex, broadcast};
use tower_http::{cors::CorsLayer, services::ServeDir};
use tracing::{error, info};
use uuid::Uuid;
use futures_util::{StreamExt, SinkExt};

#[derive(Clone)]
struct AppState {
    zkengine_binary: String,
    wasm_dir: String,
    proofs_dir: String,
    proof_store: Arc<Mutex<HashMap<String, ProofRecord>>>,
    verification_store: Arc<Mutex<Vec<VerificationRecord>>>,
    tx: broadcast::Sender<WsMessage>,
}

#[derive(Serialize, Deserialize, Clone)]
struct ProofRecord {
    id: String,
    timestamp: DateTime<Utc>,
    metadata: ProofMetadata,
    metrics: ProofMetrics,
    status: ProofStatus,
    file_path: Option<String>,
}

#[derive(Serialize, Deserialize, Clone)]
struct VerificationRecord {
    id: String,
    proof_id: String,
    timestamp: DateTime<Utc>,
    is_valid: bool,
    verification_time_secs: f64,
    error: Option<String>,
}

#[derive(Serialize, Deserialize, Clone)]
struct ProofMetadata {
    wasm_path: String,
    function: String,
    arguments: Vec<String>,
    step_size: u64,
}

#[derive(Serialize, Deserialize, Clone)]
struct ProofMetrics {
    generation_time_secs: f64,
    file_size_mb: f64,
    file_hash: String,
    peak_memory_mb: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "lowercase")]
enum ProofStatus {
    Pending,
    Running,
    Complete,
    Failed(String),
}

#[derive(Serialize, Clone)]
struct WsMessage {
    #[serde(rename = "type")]
    msg_type: String,
    content: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    data: Option<serde_json::Value>,
}

#[derive(Deserialize)]
struct ChatMessage {
    message: String,
}

#[tokio::main]
async fn main() {
    dotenv::dotenv().ok();
    tracing_subscriber::fmt::init();

    let zkengine_binary = std::env::var("ZKENGINE_BINARY")
        .unwrap_or_else(|_| "/usr/local/bin/zkengine".to_string());
    let wasm_dir = std::env::var("WASM_DIR")
        .unwrap_or_else(|_| "./zkengine_data/wasm".to_string());
    let proofs_dir = std::env::var("PROOFS_DIR")
        .unwrap_or_else(|_| "./proofs".to_string());
    let port = std::env::var("PORT")
        .unwrap_or_else(|_| "8001".to_string())
        .parse::<u16>()
        .unwrap_or(8001);

    // Create directories
    fs::create_dir_all(&proofs_dir).ok();

    // Create broadcast channel for WebSocket messages
    let (tx, _rx) = broadcast::channel::<WsMessage>(1000);

    let state = AppState {
        zkengine_binary,
        wasm_dir,
        proofs_dir,
        proof_store: Arc::new(Mutex::new(HashMap::new())),
        verification_store: Arc::new(Mutex::new(Vec::new())),
        tx: tx.clone(),
    };

    let app = Router::new()
        .route("/", get(serve_index))
        .route("/ws", get(websocket_handler))
        .route("/api/health", get(health_check))
        .route("/api/proofs", get(list_proofs))
        .route("/api/proofs/:id", get(get_proof))
        .route("/api/proofs/generate", post(generate_proof))
        .nest_service("/static", ServeDir::new("static"))
        .layer(CorsLayer::permissive())
        .with_state(state);

    let addr = format!("0.0.0.0:{}", port);
    info!("üöÄ zkEngine Agent Kit running on http://{}", addr);
    
    axum::Server::bind(&addr.parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}

async fn serve_index() -> impl IntoResponse {
    Html(include_str!("../static/index.html"))
}

async fn health_check(State(state): State<AppState>) -> impl IntoResponse {
    let binary_exists = Path::new(&state.zkengine_binary).exists();
    let wasm_dir_exists = Path::new(&state.wasm_dir).exists();
    
    Json(json!({
        "status": "ok",
        "zkengine_binary": state.zkengine_binary,
        "binary_exists": binary_exists,
        "wasm_dir": state.wasm_dir,
        "wasm_dir_exists": wasm_dir_exists,
        "proofs_dir": state.proofs_dir,
    }))
}

async fn list_proofs(State(state): State<AppState>) -> impl IntoResponse {
    let proofs = state.proof_store.lock().await;
    let proofs_list: Vec<&ProofRecord> = proofs.values().collect();
    Json(json!({
        "proofs": proofs_list,
        "count": proofs_list.len()
    }))
}

async fn get_proof(
    State(state): State<AppState>,
    axum::extract::Path(id): axum::extract::Path<String>,
) -> impl IntoResponse {
    let proofs = state.proof_store.lock().await;
    match proofs.get(&id) {
        Some(proof) => Json(json!({
            "success": true,
            "proof": proof
        })),
        None => Json(json!({
            "success": false,
            "error": "Proof not found"
        }))
    }
}

async fn generate_proof(
    State(state): State<AppState>,
    Json(request): Json<serde_json::Value>,
) -> impl IntoResponse {
    let proof_id = Uuid::new_v4().to_string();
    
    // Parse request
    let wasm_file = request["wasm_file"].as_str().unwrap_or("fibonacci.wat");
    let function = request["function"].as_str().unwrap_or("main");
    let args = request["arguments"].as_array()
        .map(|arr| arr.iter()
            .filter_map(|v| v.as_str().map(String::from))
            .collect::<Vec<_>>())
        .unwrap_or_default();
    let step_size = request["step_size"].as_u64().unwrap_or(50);
    
    let metadata = ProofMetadata {
        wasm_path: format!("{}/{}", state.wasm_dir, wasm_file),
        function: function.to_string(),
        arguments: args.clone(),
        step_size,
    };
    
    // Create proof record
    let proof_record = ProofRecord {
        id: proof_id.clone(),
        timestamp: Utc::now(),
        metadata: metadata.clone(),
        metrics: ProofMetrics {
            generation_time_secs: 0.0,
            file_size_mb: 0.0,
            file_hash: String::new(),
            peak_memory_mb: None,
        },
        status: ProofStatus::Pending,
        file_path: None,
    };
    
    state.proof_store.lock().await.insert(proof_id.clone(), proof_record.clone());
    
    // Spawn proof generation
    let state_clone = state.clone();
    let proof_id_clone = proof_id.clone();
    tokio::spawn(async move {
        generate_real_proof(state_clone, proof_id_clone, metadata, args).await;
    });
    
    Json(json!({
        "success": true,
        "proof_id": proof_id,
        "message": "Proof generation started"
    }))
}

async fn websocket_handler(
    ws: WebSocketUpgrade,
    State(state): State<AppState>,
) -> impl IntoResponse {
    ws.on_upgrade(move |socket| websocket_connection(socket, state))
}

async fn websocket_connection(socket: WebSocket, state: AppState) {
    let (mut sender, mut receiver) = socket.split();
    
    // Subscribe to broadcast channel
    let mut rx = state.tx.subscribe();
    
    // Send welcome message
    let welcome = WsMessage {
        msg_type: "message".to_string(),
        content: "Connected to zkEngine Agent Kit! Try 'prove fibonacci of 20' or 'help'.".to_string(),
        data: None,
    };
    sender.send(Message::Text(serde_json::to_string(&welcome).unwrap())).await.ok();
    
    // Spawn task to receive broadcast messages
    let send_task = tokio::spawn(async move {
        while let Ok(msg) = rx.recv().await {
            if sender.send(Message::Text(serde_json::to_string(&msg).unwrap())).await.is_err() {
                break;
            }
        }
    });
    
    while let Some(msg) = receiver.next().await {
        if let Ok(msg) = msg {
            match msg {
                Message::Text(text) => {
                    if let Ok(chat_msg) = serde_json::from_str::<ChatMessage>(&text) {
                        let response = process_nl_command(&state, &chat_msg.message).await;
                        let ws_msg = WsMessage {
                            msg_type: "message".to_string(),
                            content: response.message,
                            data: response.data,
                        };
                        // Broadcast to all clients
                        let _ = state.tx.send(ws_msg);
                    }
                }
                Message::Close(_) => break,
                _ => {}
            }
        }
    }
    
    send_task.abort();
}

struct NlResponse {
    message: String,
    data: Option<serde_json::Value>,
}

async fn process_nl_command(state: &AppState, input: &str) -> NlResponse {
    let input_lower = input.to_lowercase();
    
    // Help command
    if input_lower.contains("help") {
        return NlResponse {
            message: "ü§ñ zkEngine Agent Kit Commands:\n\n\
                     ‚Ä¢ prove fibonacci of N - Generate a Fibonacci proof\n\
                     ‚Ä¢ prove add X and Y - Prove addition\n\
                     ‚Ä¢ prove multiply X by Y - Prove multiplication\n\
                     ‚Ä¢ list all proofs - Show all generated proofs\n\
                     ‚Ä¢ list verifications - Show verification history\n\
                     ‚Ä¢ get proof <id> - Get specific proof details\n\
                     ‚Ä¢ verify - Verify last proof\n\
                     ‚Ä¢ verify proof <id> - Verify specific proof\n\
                     ‚Ä¢ status - Check system status\n\
                     ‚Ä¢ help - Show this message".to_string(),
            data: None,
        };
    }
    
    // Status command
    if input_lower.contains("status") {
        let binary_exists = Path::new(&state.zkengine_binary).exists();
        let wasm_count = fs::read_dir(&state.wasm_dir)
            .map(|entries| entries.filter_map(Result::ok).count())
            .unwrap_or(0);
        
        return NlResponse {
            message: format!("‚úÖ System Status:\n\
                            zkEngine binary: {} ({})\n\
                            WASM files available: {}\n\
                            Proofs generated: {}\n\
                            Verifications performed: {}",
                            if binary_exists { "Found" } else { "NOT FOUND" },
                            state.zkengine_binary,
                            wasm_count,
                            state.proof_store.lock().await.len(),
                            state.verification_store.lock().await.len()),
            data: None,
        };
    }
    
    // List proofs - with table display
    if input_lower.contains("list") && input_lower.contains("proof") && !input_lower.contains("verif") {
        let proofs = state.proof_store.lock().await;
        if proofs.is_empty() {
            return NlResponse {
                message: "No proofs generated yet. Try 'prove fibonacci of 10'!".to_string(),
                data: None,
            };
        }
        
        // Send structured data for table display
        let proofs_vec: Vec<ProofRecord> = proofs.values().cloned().collect();
        return NlResponse {
            message: String::new(), // Empty message since we'll use data
            data: Some(json!({
                "type": "proof_list",
                "proofs": proofs_vec,
                "count": proofs_vec.len()
            })),
        };
    }
    
    // List verifications
    if input_lower.contains("list") && input_lower.contains("verif") {
        let verifications = state.verification_store.lock().await;
        if verifications.is_empty() {
            return NlResponse {
                message: "No verifications performed yet. Try 'verify' after generating a proof!".to_string(),
                data: None,
            };
        }
        
        // Send structured data for table display
        return NlResponse {
            message: String::new(), // Empty message since we'll use data
            data: Some(json!({
                "type": "verification_list",
                "verifications": verifications.clone(),
                "count": verifications.len()
            })),
        };
    }
    
    // Verify proof
    if input_lower.contains("verify") {
        if let Some(id) = extract_proof_id(&input_lower) {
            return verify_proof_command(state, id).await;
        }
        
        // Verify last proof
        let last_proof_id = {
            let proofs = state.proof_store.lock().await;
            proofs.values()
                .max_by_key(|p| p.timestamp)
                .map(|p| p.id.clone())
        };
        
        if let Some(proof_id) = last_proof_id {
            return verify_proof_command(state, &proof_id).await;
        }
        
        return NlResponse {
            message: "No proofs to verify. Generate one first!".to_string(),
            data: None,
        };
    }
    
    // Prove commands
    if input_lower.contains("prove") {
        return handle_prove_command(state, &input_lower).await;
    }
    
    // Get proof details
    if input_lower.contains("get proof") {
        if let Some(id) = extract_proof_id(&input_lower) {
            let proofs = state.proof_store.lock().await;
            if let Some(proof) = proofs.values().find(|p| p.id.starts_with(id)) {
                return NlResponse {
                    message: format!("üìÑ Proof Details:\n\
                                    ID: {}\n\
                                    Function: {}\n\
                                    Arguments: {:?}\n\
                                    Generation Time: {:.1}s\n\
                                    File Size: {:.1}MB\n\
                                    Hash: {}...\n\
                                    Status: {:?}",
                                    &proof.id[..8],
                                    proof.metadata.function,
                                    proof.metadata.arguments,
                                    proof.metrics.generation_time_secs,
                                    proof.metrics.file_size_mb,
                                    &proof.metrics.file_hash[..16],
                                    proof.status),
                    data: Some(json!(proof)),
                };
            }
        }
        return NlResponse {
            message: "Proof not found. Use 'list all proofs' to see available proofs.".to_string(),
            data: None,
        };
    }
    
    NlResponse {
        message: "I didn't understand that. Try 'help' for available commands.".to_string(),
        data: None,
    }
}

async fn handle_prove_command(state: &AppState, input: &str) -> NlResponse {
    let proof_id = Uuid::new_v4().to_string();
    
    // Parse the prove command
    let (wasm_file, function, args, step_size) = parse_prove_command(input);
    
    let metadata = ProofMetadata {
        wasm_path: format!("{}/{}", state.wasm_dir, wasm_file),
        function: function.clone(),
        arguments: args.clone(),
        step_size,
    };
    
    // Announce what we're doing
    let announce_msg = format!(
        "üîß Starting proof generation:\n\
         ‚Ä¢ Function: {}\n\
         ‚Ä¢ Arguments: {:?}\n\
         ‚Ä¢ WASM: {}\n\
         ‚Ä¢ Steps: {}\n\
         ‚Ä¢ Proof ID: {}...\n\n\
         ‚è≥ This will take 10-30 seconds...",
        function, args, wasm_file, step_size, &proof_id[..8]
    );
    
    // Create initial proof record
    let proof_record = ProofRecord {
        id: proof_id.clone(),
        timestamp: Utc::now(),
        metadata: metadata.clone(),
        metrics: ProofMetrics {
            generation_time_secs: 0.0,
            file_size_mb: 0.0,
            file_hash: String::new(),
            peak_memory_mb: None,
        },
        status: ProofStatus::Pending,
        file_path: None,
    };
    
    state.proof_store.lock().await.insert(proof_id.clone(), proof_record);
    
    // Spawn the actual proof generation
    let state_clone = state.clone();
    let proof_id_clone = proof_id.clone();
    tokio::spawn(async move {
        generate_real_proof(state_clone, proof_id_clone, metadata, args).await;
    });
    
    NlResponse {
        message: announce_msg,
        data: Some(json!({ "proof_id": proof_id })),
    }
}

fn parse_prove_command(input: &str) -> (String, String, Vec<String>, u64) {
    let input_lower = input.to_lowercase();
    
    // Fibonacci
    if input_lower.contains("fibonacci") || input_lower.contains("fib") {
        let n = extract_number(&input_lower).unwrap_or(10);
        let step_size = if n > 15 { 100 } else { 50 };
        return ("fib.wat".to_string(), "main".to_string(), vec![n.to_string()], step_size);
    }
    
    // Addition
    if input_lower.contains("add") || input_lower.contains("sum") {
        let numbers = extract_two_numbers(&input_lower);
        return ("add.wat".to_string(), "main".to_string(), 
                vec![numbers.0.to_string(), numbers.1.to_string()], 50);
    }
    
    // Multiplication
    if input_lower.contains("multiply") || input_lower.contains("times") {
        let numbers = extract_two_numbers(&input_lower);
        return ("multiply.wat".to_string(), "main".to_string(), 
                vec![numbers.0.to_string(), numbers.1.to_string()], 50);
    }
    
    // Factorial
    if input_lower.contains("factorial") {
        let n = extract_number(&input_lower).unwrap_or(5);
        return ("factorial_i32.wat".to_string(), "main".to_string(), vec![n.to_string()], 50);
    }
    
    // Even/odd check
    if input_lower.contains("even") || input_lower.contains("odd") {
        let n = extract_number(&input_lower).unwrap_or(42);
        return ("is_even.wat".to_string(), "main".to_string(), vec![n.to_string()], 50);
    }
    
    // Square
    if input_lower.contains("square") {
        let n = extract_number(&input_lower).unwrap_or(9);
        return ("square.wat".to_string(), "main".to_string(), vec![n.to_string()], 50);
    }
    
    // Max
    if input_lower.contains("max") {
        let numbers = extract_two_numbers(&input_lower);
        return ("max.wat".to_string(), "main".to_string(), 
                vec![numbers.0.to_string(), numbers.1.to_string()], 50);
    }
    
    // Count until
    if input_lower.contains("count") {
        let n = extract_number(&input_lower).unwrap_or(10);
        return ("count_until.wat".to_string(), "main".to_string(), vec![n.to_string()], 50);
    }
    
    // Default
    ("fib.wat".to_string(), "main".to_string(), vec!["10".to_string()], 50)
}

fn extract_number(input: &str) -> Option<u32> {
    input.split_whitespace()
        .find_map(|word| word.parse::<u32>().ok())
}

fn extract_two_numbers(input: &str) -> (u32, u32) {
    let numbers: Vec<u32> = input.split_whitespace()
        .filter_map(|word| word.parse::<u32>().ok())
        .collect();
    
    match numbers.len() {
        0 => (5, 3),
        1 => (numbers[0], 2),
        _ => (numbers[0], numbers[1]),
    }
}

fn extract_proof_id(input: &str) -> Option<&str> {
    // Look for UUID-like patterns or short IDs
    input.split_whitespace()
        .find(|word| word.len() >= 8 && word.chars().all(|c| c.is_alphanumeric() || c == '-'))
}

async fn generate_real_proof(
    state: AppState,
    proof_id: String,
    metadata: ProofMetadata,
    args: Vec<String>,
) {
    let start_time = Instant::now();
    
    // Update status to running
    {
        let mut proofs = state.proof_store.lock().await;
        if let Some(proof) = proofs.get_mut(&proof_id) {
            proof.status = ProofStatus::Running;
        }
    }
    
    // Send WebSocket update
    let _ = state.tx.send(WsMessage {
        msg_type: "proof_update".to_string(),
        content: format!("üèÉ Generating proof {}...", &proof_id[..8]),
        data: Some(json!({ "proof_id": proof_id, "status": "running" })),
    });
    
    // Create proof directory
    let proof_dir = format!("{}/{}", state.proofs_dir, proof_id);
    fs::create_dir_all(&proof_dir).ok();
    
    // Check if WASM file exists
    if !Path::new(&metadata.wasm_path).exists() {
        error!("WASM file not found: {}", metadata.wasm_path);
        update_proof_failed(&state, &proof_id, "WASM file not found").await;
        return;
    }
    
    // Clone values needed inside the closure
    let zkengine_binary = state.zkengine_binary.clone();
    let wasm_path = metadata.wasm_path.clone();
    let step_size = metadata.step_size;
    let proof_dir_clone = proof_dir.clone();
    let args_vec: Vec<String> = args.clone();
    
    info!("Running zkEngine command for proof {}", proof_id);
    
    match tokio::task::spawn_blocking(move || {
        let mut cmd = Command::new(&zkengine_binary);
        cmd.arg("prove")
            .arg("--wasm").arg(&wasm_path)
            .arg("--step").arg(step_size.to_string())
            .arg("--out-dir").arg(&proof_dir_clone);
        
        // Add arguments
        for arg in args_vec {
            cmd.arg(arg);
        }
        
        cmd.stdout(Stdio::piped())
            .stderr(Stdio::piped());
        
        info!("Executing command: {:?}", cmd);
        cmd.output()
    }).await {
        Ok(Ok(output)) => {
            let duration = start_time.elapsed();
            
            if output.status.success() {
                // Find the generated proof file
                if let Ok(entries) = fs::read_dir(&proof_dir) {
                    for entry in entries.filter_map(Result::ok) {
                        let path = entry.path();
                        if path.extension().and_then(|s| s.to_str()) == Some("bin") {
                            // Calculate metrics
                            let file_size = fs::metadata(&path)
                                .map(|m| m.len() as f64 / 1_048_576.0)
                                .unwrap_or(0.0);
                            
                            let file_hash = calculate_file_hash(&path).await;
                            
                            // Update proof record
                            let mut proofs = state.proof_store.lock().await;
                            if let Some(proof) = proofs.get_mut(&proof_id) {
                                proof.status = ProofStatus::Complete;
                                proof.file_path = Some(path.to_string_lossy().to_string());
                                proof.metrics = ProofMetrics {
                                    generation_time_secs: duration.as_secs_f64(),
                                    file_size_mb: file_size,
                                    file_hash,
                                    peak_memory_mb: None,
                                };
                            }
                            
                            // Send success message - THIS WILL NOW BE BROADCAST TO ALL CLIENTS!
                            let _ = state.tx.send(WsMessage {
                                msg_type: "proof_complete".to_string(),
                                content: format!(
                                    "‚úÖ Proof generated successfully!\n\
                                     ‚Ä¢ ID: {}\n\
                                     ‚Ä¢ Time: {:.1}s\n\
                                     ‚Ä¢ Size: {:.1}MB\n\
                                     ‚Ä¢ Ready for verification",
                                    &proof_id[..8],
                                    duration.as_secs_f64(),
                                    file_size
                                ),
                                data: Some(json!({ 
                                    "proof_id": proof_id,
                                    "status": "complete",
                                    "metrics": {
                                        "time": duration.as_secs_f64(),
                                        "size_mb": file_size
                                    }
                                })),
                            });
                            
                            return;
                        }
                    }
                }
                
                // No proof file found
                update_proof_failed(&state, &proof_id, "Proof file not found after generation").await;
            } else {
                let error = String::from_utf8_lossy(&output.stderr);
                error!("zkEngine command failed: {}", error);
                update_proof_failed(&state, &proof_id, &format!("zkEngine error: {}", error)).await;
            }
        }
        Ok(Err(e)) => {
            error!("Failed to execute zkEngine: {}", e);
            update_proof_failed(&state, &proof_id, &format!("Execution error: {}", e)).await;
        }
        Err(e) => {
            error!("Task join error: {}", e);
            update_proof_failed(&state, &proof_id, "Internal error").await;
        }
    }
}

async fn update_proof_failed(state: &AppState, proof_id: &str, error: &str) {
    let mut proofs = state.proof_store.lock().await;
    if let Some(proof) = proofs.get_mut(proof_id) {
        proof.status = ProofStatus::Failed(error.to_string());
    }
    
    let _ = state.tx.send(WsMessage {
        msg_type: "proof_failed".to_string(),
        content: format!("‚ùå Proof generation failed: {}", error),
        data: Some(json!({ "proof_id": proof_id, "error": error })),
    });
}

async fn calculate_file_hash(path: &Path) -> String {
    match tokio::fs::read(path).await {
        Ok(contents) => {
            let mut hasher = Sha256::new();
            hasher.update(&contents);
            format!("{:x}", hasher.finalize())
        }
        Err(_) => "error".to_string(),
    }
}

async fn verify_proof_command(state: &AppState, proof_id: &str) -> NlResponse {
    let proofs = state.proof_store.lock().await;
    
    // Find proof with matching ID prefix
    let proof = proofs.values().find(|p| p.id.starts_with(proof_id)).cloned();
    drop(proofs);
    
    if let Some(proof) = proof {
        if let ProofStatus::Complete = &proof.status {
            if let Some(proof_path) = &proof.file_path {
                // Send verification started message
                let _ = state.tx.send(WsMessage {
                    msg_type: "verification_start".to_string(),
                    content: format!("üîç Starting verification of proof {}...", &proof.id[..8]),
                    data: Some(json!({ "proof_id": proof.id })),
                });
                
                let start_time = Instant::now();
                let verification_id = Uuid::new_v4().to_string();
                
                // Find the proof directory and public.json
                let proof_dir = Path::new(proof_path).parent()
                    .ok_or("Invalid proof path")
                    .map_err(|e| {
                        return NlResponse {
                            message: format!("‚ùå Error: {}", e),
                            data: None,
                        };
                    });
                
                if let Ok(proof_dir) = proof_dir {
                    // Run actual zkEngine verify command
                    let zkengine_binary = state.zkengine_binary.clone();
                    let proof_dir_str = proof_dir.to_string_lossy().to_string();
                    
                    match tokio::task::spawn_blocking(move || {
                        let mut cmd = Command::new(&zkengine_binary);
                        cmd.arg("verify")
                            .arg("--out-dir").arg(&proof_dir_str)
                            .stdout(Stdio::piped())
                            .stderr(Stdio::piped());
                        
                        info!("Executing verify command: {:?}", cmd);
                        cmd.output()
                    }).await {
                        Ok(Ok(output)) => {
                            let duration = start_time.elapsed();
                            let is_valid = output.status.success();
                            let output_str = String::from_utf8_lossy(&output.stdout);
                            
                            // Create verification record
                            let verification = VerificationRecord {
                                id: verification_id,
                                proof_id: proof.id.clone(),
                                timestamp: Utc::now(),
                                is_valid,
                                verification_time_secs: duration.as_secs_f64(),
                                error: if !is_valid {
                                    Some(String::from_utf8_lossy(&output.stderr).to_string())
                                } else {
                                    None
                                },
                            };
                            
                            // Store verification
                            state.verification_store.lock().await.push(verification.clone());
                            
                            // Send result
                            return NlResponse {
                                message: format!(
                                    "{} Proof Verification Complete!\n\
                                     ‚Ä¢ Proof ID: {}\n\
                                     ‚Ä¢ Function: {} with args {:?}\n\
                                     ‚Ä¢ Proof Size: {:.1}MB\n\
                                     ‚Ä¢ Verification Time: {:.3}s\n\
                                     ‚Ä¢ Result: {}\n{}",
                                    if is_valid { "‚úÖ" } else { "‚ùå" },
                                    &proof.id[..8],
                                    proof.metadata.function,
                                    proof.metadata.arguments,
                                    proof.metrics.file_size_mb,
                                    duration.as_secs_f64(),
                                    if is_valid { "VALID ‚úì" } else { "INVALID ‚úó" },
                                    if !output_str.is_empty() { format!("\nOutput: {}", output_str.trim()) } else { String::new() }
                                ),
                                data: Some(json!({
                                    "type": "verification_complete",
                                    "verification": verification,
                                    "proof": proof,
                                })),
                            };
                        }
                        Ok(Err(e)) => {
                            return NlResponse {
                                message: format!("‚ùå Failed to execute verification: {}", e),
                                data: None,
                            };
                        }
                        Err(e) => {
                            return NlResponse {
                                message: format!("‚ùå Verification error: {}", e),
                                data: None,
                            };
                        }
                    }
                }
            }
        }
        
        return NlResponse {
            message: format!("Proof {} is not ready for verification. Status: {:?}", 
                           &proof.id[..8], proof.status),
            data: None,
        };
    }
    
    NlResponse {
        message: "Proof not found. Use 'list all proofs' to see available proofs.".to_string(),
        data: None,
    }
}
